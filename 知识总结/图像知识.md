## 图像知识  
### 彩色空间
- **基础知识**  
	- **特性**  
	  - 通常区别不同颜色特性的是**亮度，色调和饱和度**。   
	    其中亮度表达的是无色的亮度概念，色调表示感知者感知的主要颜色，饱和度指的是相对纯净度或是混合白光的数量(纯谱色是全饱和的，混合白光越多饱和度越低，**饱和度和所加白光的数量成反比**，如深红色(红加白)，淡紫色(紫加白)这样的颜色是欠饱和的)。  
	  - 色调与饱和度一起成为色度，颜色可用亮度和色度表示。
  - **三色值**  
    形成任何彩色的**红绿蓝**的数量成为三色值，并分别表示为X,Y,Z。则一种颜色就可以由三色值系数定义为：   
    $x =\frac{X}{X+Y+Z}$  
    
    $y =\frac{Y}{X+Y+Z}$  
    
    $z =\frac{Z}{X+Y+Z}$
    从以上可以得知，x+y+z = 1  
 - **彩色空间**    
   本质上，彩色空间是坐标系统和子空间的说明，其中，位于系统中的每一个点代表一种颜色。 
   常见彩色空间：RGB（红绿蓝），CMY(青，粉红，黄)，CMYK（青，粉红，黄，黑），HSI（色调，饱和度，亮度）  
   
   - **RGB**  
     该模型基于笛卡尔坐标系，以红色，绿色，蓝色（R,G,B）为三个坐标轴，RGB原色值位于3个角上；二次色青色，深红色，黄色位于另外3个角上，黑色位于原点，白色位于离原点最远的点。**灰度(RGB相等的点)沿着连接这两个点的直线从黑色延伸到白色**。   
     RGB彩色模型中表示的图像由三个分量图像组成，每种原色一幅分量图像。其中每幅红绿蓝图像都是一幅8比特图像，术语全彩色图像通常用来表示一幅24比特的RGB彩色图像(三个图像平面乘以每个平面比特数)。  
   ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560432575%281%29.jpg)   
	   - **RGB中的亮度和饱和度**  
	     RGB彩色图像可视为3幅单色**亮度**图像(红色，绿色和蓝色)。  
	     
	     亮度是沿连接两个顶点的直线分布的（即灰度轴这条线），彩色点与灰度轴垂直交点的值，即取间[0,1]内的强度值。  
	     
	     饱和度以强度轴的距离为函数而增大，强度轴上的点饱和度为0。事实证明沿着这条轴线的所有点都是灰度。    
	     
	     由强度轴和立方体边界定义的平面内所有点，都有相同的色调。即如果两个点是黑点和白点，第三个点是彩色点，那么这个三角形平面上的所有点有相同的色调，因为黑分量和白分量不能改变色调，当然这个平面内点的饱和度和强度是不同的。关于垂直强度轴旋转阴影平面，可得到不同色调。  
	        ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560518862%281%29.jpg)
	    - 总结  
	      - 彩色图像就是3幅单色图像的亮度图像混合在一起。每幅单色图像上数值，代表着该色调的强度，三幅单色图不同色调，按不同强度混合得到彩色图像。
	      - 灰度图像是只有亮度，没有饱和度，即饱和度为零。灰度图像按强度区分。
   - **CMY和CMYK**  
	    青色、深红色和黄色是光的二次色。彩色打印机和复印机，要求输入CMY数据或在内部将RGB转换成CMY。  
	    - 转换公式
	    RGB转换为CMY:    
	   $\begin{bmatrix} C\\ M\\Y\\\end{bmatrix}$=$\begin{bmatrix}1\\1\\1\\\end{bmatrix}$-$\begin{bmatrix}R\\G\\B\\\end{bmatrix}$  
	   
		    此公式假设所有彩色值都归一化到了取间[0,1]。青色反射的光中不含红色，故C=1-R。类似的，深红色不反射绿色，纯黄色不反射蓝色。故上述公式可得。 
	     
	    该模式生成的黑色不纯，为了生成真正的黑色混入第四种颜色，提出CMYK彩色模型  
	- **HSI**  
	    HSI(色调，饱和度和强度)  
	    >HSI 色彩模型是从人的视觉系统出发。在图像处理和计算机视觉中大量算法都可在HSI色彩空间中 方便地使用，它们可以分开处理而且是相互独立的。因此，在HSI色彩空间可以大大简化图像分析 和处理的工作量  
	    
	
    由上面RGB的色调，强度，饱和度知识可知，任何RGB中点都可转换成对应HSI中点。  
	    由上面个RGB的色调，强度，饱和度知识可知，HSI空间由RGB空间中垂直强度轴和位于与该轴垂直的平面内的彩色点轨迹表示。沿灰度轴向下投影，可得到如下图a的六边形图。原色按120度分割，二次色与原色相隔60度。将红色定义为0度角的话，逆时针增长，**角度大小就可以表示色调。饱和度则可表示为原点到某点的向量长度。强度则是立体图形垂直轴的高度**。  当然，HSI也可以表示为三角形和原型。
	    ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520030%281%29.jpg)   
	    - **从RGB到HSI**  
	      根据上述知识，每个RGB像素的H分量可由下式计算：   
	      
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520284%281%29.jpg)    
	       
	      饱和度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520304%281%29.jpg)  
	       
	      强度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520325%281%29.jpg)   
	      
	    - 从HSI到RGB   
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016.jpg)     
	           ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016%281%29.jpg)   
	 - **YCbCr/YUV**       
	   YUV彩色空间广泛用于数字视频。亮度信息用单独的分量Y来表示，彩色信息是用两个色差分量Cb和Cr来存储的。分量Cb是蓝色分量与参考值的差，分量Cr是红色分量与参考值的差。  
	   
	   亮度信号Y和两个色差信号R－Y（即U）、B－Y（即V）  
	   
	   与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。  
	   采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。

	- SHV  
	  与HSI相似，用明度代替V代替了亮度I。两者区别参考：[https://blog.csdn.net/binglan520/article/details/56288135](https://blog.csdn.net/binglan520/article/details/56288135)

-  各彩色空间的转换代码（基于python opencv）  
	- BGR RGB GBR间转换 (基于列表实现)
		- BGR to RGB  
		  OpenCV image to Matplotlib  
		  `rgb = bgr[...,::-1]`
		-  RGB to BGR  
		  Matplotlib image to OpenCV  
		  `bgr = rgb[...,::-1]`  
		-  RGB to GBR  
		  `gbr = rgb[...,[2,0,1]]`  
		  
   - python中opencv库函数的转换方法  
      将RGB图像转换为HSV及YCrCb图像，主要使用了cv2库中的cv2.cvtColor()函数，将RGB图像（**在opencv中设计BGR图像**）转换为HSV图像用到了参数cv2.COLOR_BGR2HSV，而转换为YCrCb图像用到了参数cv2.COLOR_BGR2YCrCb或者cv2.COLOR_BGR2YCR_CB。    
      - 基础概念  
        在opencv中读入默认为BGR顺序，而其他一般使用RGB，所以需要转换  
       
        例如：opencv默认的imread是以BGR的方式进行存储的,而matplotlib的imshow默认则是以RGB格式展示,所以需要对图片的通道进行转换
        ```  
        lenna_img = cv2.cvtColor(lenna_img,cv2.COLOR_BGR2RGB)
        plt.imshow(lenna_img)
        plt.axis("off")
        plt.show()
        ```  
      - BGR RGB间转换  
        ```
        img_bgr = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        ```
      - BGR转HSV  
        `img_hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)`
      - BGR转YCrCb  
        `img_ycrcb = cv2.cvtColor(img,cv2.COLOR_BGR2YCrCb)`  
      - BGR转灰度图  
        `img1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)`
### 滤波   
- 线性滤波   
   - 高斯滤波   
     高斯滤波是一种线性滤波，也是一种低通滤波，利用二维高斯函数的分布方式来对图像进行平滑。     
     图像与**服从二维正态分布的卷积核**做卷积。
     - 公式    
       
       一维零均值高斯函数为：   
       ![enter image description here](https://lh3.googleusercontent.com/l-Ggun_vc6c24c8PXJyqiAcyAE3wzwXz78Xz4kgCHaNISLSB7DumvxeWBak22JyGfKhPnZHJPrHx)    
           
       对于二维图像来说，常用二维零均值离散高斯函数作平滑滤波器。  
       二维高斯函数为：   
       ![enter image description here](https://lh3.googleusercontent.com/NoCjUDXZh6jdTyem3TKv38erW_RVfCXjVZxElVf1p7Wb6iCr9IzsxLy5focGfAy60BjJA1uG_Lck)    
       
     - 优点  
       首先，二维高斯函数是旋转对称的，在各个方向上平滑程度相同，不会改变原图像的边缘走向。
       其次，高斯函数是单值函数，高斯卷积核的锚点为极值，在所有方向上单调递减，锚点像素不会受到距离锚点较远的像素影响过大，保证了特征点和边缘的特性。
- 非线性滤波
	- 中值滤波   
	  简言之中值滤波就是把函数框（如图中的3 X 3）内的灰度值按顺序排列，然后中值取代函数框中心的灰度值。所以一般采用奇数点的邻域来计算中值，但如果像素点数为偶数，中值就取排序像素中间两点的平均值。   
	  - 优点  
	    中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。  
	  - 缺点   
	    因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上
	- 双边滤波   
	   双边滤波（Bilateral filter）是一种非线性的滤波方法，是**结合图像的空间邻近度和像素值相似度**的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。   
	   
	   双边滤波器的好处是可以做边缘保存（edge preserving），一般用高斯滤波去降噪，会较明显地模糊边缘，对于高频细节的保护效果并不明显。双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。    
	   
	   距离越近权重越大，这一点和方框滤波，高斯滤波方式相同。而r函数则是根据像素的差异来分配权值。如果两个像素值越接近，即使相距较远，也比差异大而距离近的像素点权重大。正是r函数的作用，使得边缘，即相距近但差异大的像素点的特性得以保留。
	   参考：[https://www.jianshu.com/p/8d11e26c9665]   
### 图像数字化   
- 图像采样   
  图像在位置上的离散化叫做采样。
  采样图像的均匀量化。   

- 数字图像主要由采样点数和灰度级决定。采样点数和灰度级也决定图像的数据量和图像分辨率。     
  - N和k与图像分辨率的关系   
	  - 空间分辨率    
	     空间分辨率与采样点数N相关   
	 - 幅度分辨率  
	   幅度分辨率与灰度级k有关
### 图像增强   
- **图像对比度增强**   
  图像成像过程中，由于环境限制等因素影响，生成图像往往对比度不足，造成图像的视觉效果差。   
  对此，可采用图像灰度值变换的方法，改变灰度值从而改变图像灰度的动态范围，增强图像对比度。公式可表示为：   
  $$g(m,n)=T[f(m,n)]$$   
  - **灰度线性变换**   
	- **线性变换**
	    灰度线性变换是将图像灰度值按给定线性函数进行变换，增强或减弱图像的灰度，达到增强图像对比度的目的。   
	    设原图像灰度范围$f(m,n) \in [a,b]$，线性变换后为$g(m,n)\in [c,d]$。线性变换公式为：   
	    $$g(m,n)=c+k[f(m,n)-a]$$   
	    - 扩展动态范围   
	      当k>1，结果会使图像的动态范围展宽，可以改善曝光不足的缺陷。   
	    -  改变取值取间   
	     当k=1时，动态范围不变，取值取间会平移。
	    - 缩小动态范围   
	     0<k<1时，图像的动态范围会变窄。   
	    - 取反   
	     当k<0时，灰度值反转，亮的地方变暗，暗的地方变亮。  
    - **灰度分段线性变换**    
	    有些情况下，图像的整个灰度范围很宽，但感兴趣的灰度值的动态范围窄。可以分段线性变换   
	     - 扩展感兴趣的，牺牲其他   
	       对感兴趣的用大于1的k来扩展，其他区间用固定值表示。
	    - 扩展感兴趣的，压缩其他   
	       与以上不同的时，不感兴趣的其他区间压缩的方法。  
  - **非线性变换**    
     - **对数变换**   
     
       表达式：$g(m,n)=\lambda lg[1+f(m,n)]$   
       
       $\lambda$作为调节常数，调节变换后的灰度。对数变换的作用是扩展图像的低灰度范围，压缩图像的高灰度范围，使得图像的灰度分布均匀，与人的视觉特性相匹配。   
   - **指数变换**  
     与对数变换相反，指数变换是压缩图像的低灰度范围，扩展图像的高灰度范围：   
     $$g(m,n)=\lambda [f(m,n)+\epsilon]^\gamma$$  
     当$\gamma<1$，将原图像的灰度向高亮度映射，当图像整体偏暗时，可以应用此情况。当$\gamma>1$，将图像灰度向低亮度映射，当图像有“冲淡”外观时，可以应用此情况。   

- **图像直方图修正**    
  - 直方图均衡化是对原图进行灰度变换，使变换后图像的直方图均匀分布，使大区域中微笑灰度变化显现出来。直方图均衡化就是对图像进行非线性拉伸         
  - 必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界   
  - 步骤：  
    - 统计各个灰度级的像素值个数  
    - 计算图像的直方图，即各个灰度级的出现概率。  
    - 计算累计分布函数，即累计直方图   
    - 利用映射函数，根据灰度值以及对应的累计分布函数对应值，进行公式计算，得到对应新的灰度值。   
       $$s_k = T(r_k)$$   
       公式可以有多种：  
         - 直接输出，将累计分布函数对应的值直接作为新灰度值
         - $h(v) = round(\frac{cdf(v)-cdf_{min}}{M*N-cdf_{min}})*(L-1)$  
           > 其中cdf(v)代表对应累计分布函数的值，cdf_min代表分布函数中最小值，M,N分别代表长度宽度。L代表灰度级个数（通常为8位动态范围，256个灰度级）   
        - $h(v)=INT((L-1)*cdf(v)+0.5)$

   - 结果：
     - 把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布
     - 其结果扩展了图像的动态范围
   
- **直方图规定化**  
  - 直方图均衡化能自动增强图像的整体对比度，但是往往结果难以受到控制。实际中常常需要增强某个特定灰度值范围内的对比度或使图像灰度值的分布满足特定需求。这个时候使用直方图规定化会有较好的结果。  
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU3MzUyNjA5MSwtMTQzMzYyMDk5MywtMz
UxMDc1OTA1LDM5NzI3ODcxNyw5MzI1NTYzNjQsMjg4NDIyMDEs
ODcwNzQ5OTQzLC0xMzY2Mzk1ODMwLC0xNzI3NTc3NzUwLDMzNj
c2OTI0MywtMTU1OTk2OTE2MiwtODUyMjkwNjkxLC00MTc5OTcy
MzMsLTE5OTQ2NzA4NDgsMTA2MDEyOTgwLC0xNzE1OTU4MTk5LD
E0NDY3NjEzNjUsMTYzNTI3NDQwMywtNzg1Nzk5MzI4LC0xNjM2
NDIwNzMxXX0=
-->