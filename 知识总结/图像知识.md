## 图像知识  
### 彩色空间
- **基础知识**  
	- **特性**  
	  - 通常区别不同颜色特性的是**亮度，色调和饱和度**。   
	    其中亮度表达的是无色的亮度概念，色调表示感知者感知的主要颜色，饱和度指的是相对纯净度或是混合白光的数量(纯谱色是全饱和的，混合白光越多饱和度越低，**饱和度和所加白光的数量成反比**，如深红色(红加白)，淡紫色(紫加白)这样的颜色是欠饱和的)。  
	  - 色调与饱和度一起成为色度，颜色可用亮度和色度表示。
  - **三色值**  
    形成任何彩色的**红绿蓝**的数量成为三色值，并分别表示为X,Y,Z。则一种颜色就可以由三色值系数定义为：   
    $x =\frac{X}{X+Y+Z}$  
    
    $y =\frac{Y}{X+Y+Z}$  
    
    $z =\frac{Z}{X+Y+Z}$
    从以上可以得知，x+y+z = 1  
 - **彩色空间**    
   本质上，彩色空间是坐标系统和子空间的说明，其中，位于系统中的每一个点代表一种颜色。 
   常见彩色空间：RGB（红绿蓝），CMY(青，粉红，黄)，CMYK（青，粉红，黄，黑），HSI（色调，饱和度，亮度）  
   
   - **RGB**  
     该模型基于笛卡尔坐标系，以红色，绿色，蓝色（R,G,B）为三个坐标轴，RGB原色值位于3个角上；二次色青色，深红色，黄色位于另外3个角上，黑色位于原点，白色位于离原点最远的点。**灰度(RGB相等的点)沿着连接这两个点的直线从黑色延伸到白色**。   
     RGB彩色模型中表示的图像由三个分量图像组成，每种原色一幅分量图像。其中每幅红绿蓝图像都是一幅8比特图像，术语全彩色图像通常用来表示一幅24比特的RGB彩色图像(三个图像平面乘以每个平面比特数)。  
   ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560432575%281%29.jpg)   
	   - **RGB中的亮度和饱和度**  
	     RGB彩色图像可视为3幅单色**亮度**图像(红色，绿色和蓝色)。  
	     
	     亮度是沿连接两个顶点的直线分布的（即灰度轴这条线），彩色点与灰度轴垂直交点的值，即取间[0,1]内的强度值。  
	     
	     饱和度以强度轴的距离为函数而增大，强度轴上的点饱和度为0。事实证明沿着这条轴线的所有点都是灰度。    
	     
	     由强度轴和立方体边界定义的平面内所有点，都有相同的色调。即如果两个点是黑点和白点，第三个点是彩色点，那么这个三角形平面上的所有点有相同的色调，因为黑分量和白分量不能改变色调，当然这个平面内点的饱和度和强度是不同的。关于垂直强度轴旋转阴影平面，可得到不同色调。  
	        ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560518862%281%29.jpg)
	    - 总结  
	      - 彩色图像就是3幅单色图像的亮度图像混合在一起。每幅单色图像上数值，代表着该色调的强度，三幅单色图不同色调，按不同强度混合得到彩色图像。
	      - 灰度图像是只有亮度，没有饱和度，即饱和度为零。灰度图像按强度区分。
   - **CMY和CMYK**  
	    青色、深红色和黄色是光的二次色。彩色打印机和复印机，要求输入CMY数据或在内部将RGB转换成CMY。  
	    - 转换公式
	    RGB转换为CMY:    
	   $\begin{bmatrix} C\\ M\\Y\\\end{bmatrix}$=$\begin{bmatrix}1\\1\\1\\\end{bmatrix}$-$\begin{bmatrix}R\\G\\B\\\end{bmatrix}$  
	   
		    此公式假设所有彩色值都归一化到了取间[0,1]。青色反射的光中不含红色，故C=1-R。类似的，深红色不反射绿色，纯黄色不反射蓝色。故上述公式可得。 
	     
	    该模式生成的黑色不纯，为了生成真正的黑色混入第四种颜色，提出CMYK彩色模型  
	- **HSI**  
	    HSI(色调，饱和度和强度)  
	    >HSI 色彩模型是从人的视觉系统出发。在图像处理和计算机视觉中大量算法都可在HSI色彩空间中 方便地使用，它们可以分开处理而且是相互独立的。因此，在HSI色彩空间可以大大简化图像分析 和处理的工作量  
	    
	
    由上面RGB的色调，强度，饱和度知识可知，任何RGB中点都可转换成对应HSI中点。  
	    由上面个RGB的色调，强度，饱和度知识可知，HSI空间由RGB空间中垂直强度轴和位于与该轴垂直的平面内的彩色点轨迹表示。沿灰度轴向下投影，可得到如下图a的六边形图。原色按120度分割，二次色与原色相隔60度。将红色定义为0度角的话，逆时针增长，**角度大小就可以表示色调。饱和度则可表示为原点到某点的向量长度。强度则是立体图形垂直轴的高度**。  当然，HSI也可以表示为三角形和原型。
	    ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520030%281%29.jpg)   
	    - **从RGB到HSI**  
	      根据上述知识，每个RGB像素的H分量可由下式计算：   
	      
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520284%281%29.jpg)    
	       
	      饱和度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520304%281%29.jpg)  
	       
	      强度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520325%281%29.jpg)   
	      
	    - 从HSI到RGB   
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016.jpg)     
	           ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016%281%29.jpg)   
	 - **YCbCr/YUV**       
	   YUV彩色空间广泛用于数字视频。亮度信息用单独的分量Y来表示，彩色信息是用两个色差分量Cb和Cr来存储的。分量Cb是蓝色分量与参考值的差，分量Cr是红色分量与参考值的差。  
	   
	   亮度信号Y和两个色差信号R－Y（即U）、B－Y（即V）  
	   
	   与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。  
	   采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。

	- SHV  
	  与HSI相似，用明度代替V代替了亮度I。两者区别参考：[https://blog.csdn.net/binglan520/article/details/56288135](https://blog.csdn.net/binglan520/article/details/56288135)

-  各彩色空间的转换代码（基于python opencv）  
	- BGR RGB GBR间转换 (基于列表实现)
		- BGR to RGB  
		  OpenCV image to Matplotlib  
		  `rgb = bgr[...,::-1]`
		-  RGB to BGR  
		  Matplotlib image to OpenCV  
		  `bgr = rgb[...,::-1]`  
		-  RGB to GBR  
		  `gbr = rgb[...,[2,0,1]]`  
		  
   - python中opencv库函数的转换方法  
      将RGB图像转换为HSV及YCrCb图像，主要使用了cv2库中的cv2.cvtColor()函数，将RGB图像（**在opencv中设计BGR图像**）转换为HSV图像用到了参数cv2.COLOR_BGR2HSV，而转换为YCrCb图像用到了参数cv2.COLOR_BGR2YCrCb或者cv2.COLOR_BGR2YCR_CB。    
      - 基础概念  
        在opencv中读入默认为BGR顺序，而其他一般使用RGB，所以需要转换  
       
        例如：opencv默认的imread是以BGR的方式进行存储的,而matplotlib的imshow默认则是以RGB格式展示,所以需要对图片的通道进行转换
        ```  
        lenna_img = cv2.cvtColor(lenna_img,cv2.COLOR_BGR2RGB)
        plt.imshow(lenna_img)
        plt.axis("off")
        plt.show()
        ```  
      - BGR RGB间转换  
        ```
        img_bgr = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        ```
      - BGR转HSV  
        `img_hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)`
      - BGR转YCrCb  
        `img_ycrcb = cv2.cvtColor(img,cv2.COLOR_BGR2YCrCb)`  
      - BGR转灰度图  
        `img1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)`
### 滤波   
- 线性滤波   
   - 高斯滤波   
     高斯滤波是一种线性滤波，也是一种低通滤波，利用二维高斯函数的分布方式来对图像进行平滑。   
     - 优点  
       首先，二维高斯函数是旋转对称的，在各个方向上平滑程度相同，不会改变原图像的边缘走向。
       其次，高斯函数是单值函数，高斯卷积核的锚点为极值，在所有方向上单调递减，锚点像素不会受到距离锚点较远的像素影响过大，保证了特征点和边缘的特性。
- 非线性滤波
	- 中值滤波   
	  简言之中值滤波就是把函数框（如图中的3 X 3）内的灰度值按顺序排列，然后中值取代函数框中心的灰度值。所以一般采用奇数点的邻域来计算中值，但如果像素点数为偶数，中值就取排序像素中间两点的平均值。   
	  - 优点  
	    中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。  
	  - 缺点   
	    因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上
	- 双边滤波   
	   双边滤波（Bilateral filter）是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。   
	   
	   双边滤波器的好处是可以做边缘保存（edge preserving），一般用高斯滤波去降噪，会较明显地模糊边缘，对于高频细节的保护效果并不明显。双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwNjMzNjY2NDQsLTE1NTk5NjkxNjIsLT
g1MjI5MDY5MSwtNDE3OTk3MjMzLC0xOTk0NjcwODQ4LDEwNjAx
Mjk4MCwtMTcxNTk1ODE5OSwxNDQ2NzYxMzY1LDE2MzUyNzQ0MD
MsLTc4NTc5OTMyOCwtMTYzNjQyMDczMSwxNzE1NDQ0MTQ1LDMy
ODIzODgwMCw0MzIzNjM2OTYsMjY0NDQyNTgyLC0xNzA0MTY3Nz
QzXX0=
-->