## 图像知识  
### 彩色空间
- **基础知识**  
	- **特性**  
	  - 通常区别不同颜色特性的是**亮度，色调和饱和度**。   
	    其中亮度表达的是无色的亮度概念，色调表示感知者感知的主要颜色，饱和度指的是相对纯净度或是混合白光的数量(纯谱色是全饱和的，混合白光越多饱和度越低，**饱和度和所加白光的数量成反比**，如深红色(红加白)，淡紫色(紫加白)这样的颜色是欠饱和的)。  
	  - 色调与饱和度一起成为色度，颜色可用亮度和色度表示。
  - **三色值**  
    形成任何彩色的**红绿蓝**的数量成为三色值，并分别表示为X,Y,Z。则一种颜色就可以由三色值系数定义为：   
    $x =\frac{X}{X+Y+Z}$  
    
    $y =\frac{Y}{X+Y+Z}$  
    
    $z =\frac{Z}{X+Y+Z}$
    从以上可以得知，x+y+z = 1  
 - **彩色空间**    
   本质上，彩色空间是坐标系统和子空间的说明，其中，位于系统中的每一个点代表一种颜色。 
   常见彩色空间：RGB（红绿蓝），CMY(青，粉红，黄)，CMYK（青，粉红，黄，黑），HSI（色调，饱和度，亮度）  
   
   - **RGB**  
     该模型基于笛卡尔坐标系，以红色，绿色，蓝色（R,G,B）为三个坐标轴，RGB原色值位于3个角上；二次色青色，深红色，黄色位于另外3个角上，黑色位于原点，白色位于离原点最远的点。**灰度(RGB相等的点)沿着连接这两个点的直线从黑色延伸到白色**。   
     RGB彩色模型中表示的图像由三个分量图像组成，每种原色一幅分量图像。其中每幅红绿蓝图像都是一幅8比特图像，术语全彩色图像通常用来表示一幅24比特的RGB彩色图像(三个图像平面乘以每个平面比特数)。  
   ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560432575%281%29.jpg)   
	   - **RGB中的亮度和饱和度**  
	     RGB彩色图像可视为3幅单色**亮度**图像(红色，绿色和蓝色)。  
	     
	     亮度是沿连接两个顶点的直线分布的（即灰度轴这条线），彩色点与灰度轴垂直交点的值，即取间[0,1]内的强度值。  
	     
	     饱和度以强度轴的距离为函数而增大，强度轴上的点饱和度为0。事实证明沿着这条轴线的所有点都是灰度。    
	     
	     由强度轴和立方体边界定义的平面内所有点，都有相同的色调。即如果两个点是黑点和白点，第三个点是彩色点，那么这个三角形平面上的所有点有相同的色调，因为黑分量和白分量不能改变色调，当然这个平面内点的饱和度和强度是不同的。关于垂直强度轴旋转阴影平面，可得到不同色调。  
	        ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560518862%281%29.jpg)
	    - 总结  
	      - 彩色图像就是3幅单色图像的亮度图像混合在一起。每幅单色图像上数值，代表着该色调的强度，三幅单色图不同色调，按不同强度混合得到彩色图像。
	      - 灰度图像是只有亮度，没有饱和度，即饱和度为零。灰度图像按强度区分。
   - **CMY和CMYK**  
	    青色、深红色和黄色是光的二次色。彩色打印机和复印机，要求输入CMY数据或在内部将RGB转换成CMY。  
	    - 转换公式
	    RGB转换为CMY:    
	   $\begin{bmatrix} C\\ M\\Y\\\end{bmatrix}$=$\begin{bmatrix}1\\1\\1\\\end{bmatrix}$-$\begin{bmatrix}R\\G\\B\\\end{bmatrix}$  
	   
		    此公式假设所有彩色值都归一化到了取间[0,1]。青色反射的光中不含红色，故C=1-R。类似的，深红色不反射绿色，纯黄色不反射蓝色。故上述公式可得。 
	     
	    该模式生成的黑色不纯，为了生成真正的黑色混入第四种颜色，提出CMYK彩色模型  
	- **HSI**  
	    HSI(色调，饱和度和强度)  
	    >HSI 色彩模型是从人的视觉系统出发。在图像处理和计算机视觉中大量算法都可在HSI色彩空间中 方便地使用，它们可以分开处理而且是相互独立的。因此，在HSI色彩空间可以大大简化图像分析 和处理的工作量  
	    
	
    由上面RGB的色调，强度，饱和度知识可知，任何RGB中点都可转换成对应HSI中点。  
	    由上面个RGB的色调，强度，饱和度知识可知，HSI空间由RGB空间中垂直强度轴和位于与该轴垂直的平面内的彩色点轨迹表示。沿灰度轴向下投影，可得到如下图a的六边形图。原色按120度分割，二次色与原色相隔60度。将红色定义为0度角的话，逆时针增长，**角度大小就可以表示色调。饱和度则可表示为原点到某点的向量长度。强度则是立体图形垂直轴的高度**。  当然，HSI也可以表示为三角形和原型。
	    ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520030%281%29.jpg)   
	    - **从RGB到HSI**  
	      根据上述知识，每个RGB像素的H分量可由下式计算：   
	      
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520284%281%29.jpg)    
	       
	      饱和度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520304%281%29.jpg)  
	       
	      强度分量由下式计算：  
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560520325%281%29.jpg)   
	      
	    - 从HSI到RGB   
	      ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016.jpg)     
	           ![enter image description here](https://github.com/sfxz035/DL-Learning/raw/master/picture/1560521016%281%29.jpg)   
	 - **YCbCr/YUV**       
	   YUV彩色空间广泛用于数字视频。亮度信息用单独的分量Y来表示，彩色信息是用两个色差分量Cb和Cr来存储的。分量Cb是蓝色分量与参考值的差，分量Cr是红色分量与参考值的差。  
	   
	   亮度信号Y和两个色差信号R－Y（即U）、B－Y（即V）  
	   
	   与RGB视频信号传输相比，它最大的优点在于只需占用极少的频宽（RGB要求三个独立的视频信号同时传输）。  
	   采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。

	- SHV  
	  与HSI相似，用明度代替V代替了亮度I。两者区别参考：[https://blog.csdn.net/binglan520/article/details/56288135](https://blog.csdn.net/binglan520/article/details/56288135)

-  各彩色空间的转换代码（基于python opencv）  
	- BGR RGB GBR间转换 (基于列表实现)
		- BGR to RGB  
		  OpenCV image to Matplotlib  
		  `rgb = bgr[...,::-1]`
		-  RGB to BGR  
		  Matplotlib image to OpenCV  
		  `bgr = rgb[...,::-1]`  
		-  RGB to GBR  
		  `gbr = rgb[...,[2,0,1]]`  
		  
   - python中opencv库函数的转换方法  
      将RGB图像转换为HSV及YCrCb图像，主要使用了cv2库中的cv2.cvtColor()函数，将RGB图像（**在opencv中设计BGR图像**）转换为HSV图像用到了参数cv2.COLOR_BGR2HSV，而转换为YCrCb图像用到了参数cv2.COLOR_BGR2YCrCb或者cv2.COLOR_BGR2YCR_CB。    
      - 基础概念  
        在opencv中读入默认为BGR顺序，而其他一般使用RGB，所以需要转换  
       
        例如：opencv默认的imread是以BGR的方式进行存储的,而matplotlib的imshow默认则是以RGB格式展示,所以需要对图片的通道进行转换
        ```  
        lenna_img = cv2.cvtColor(lenna_img,cv2.COLOR_BGR2RGB)
        plt.imshow(lenna_img)
        plt.axis("off")
        plt.show()
        ```  
      - BGR RGB间转换  
        ```
        img_bgr = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        ```
      - BGR转HSV  
        `img_hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)`
      - BGR转YCrCb  
        `img_ycrcb = cv2.cvtColor(img,cv2.COLOR_BGR2YCrCb)`  
      - BGR转灰度图  
        `img1 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)`
### 滤波   
- 线性滤波   
   - 高斯滤波   
     高斯滤波是一种线性滤波，也是一种低通滤波，利用二维高斯函数的分布方式来对图像进行平滑。     
     图像与**服从二维正态分布的卷积核**做卷积。
     - 公式    
       
       一维零均值高斯函数为：   
       ![enter image description here](https://lh3.googleusercontent.com/l-Ggun_vc6c24c8PXJyqiAcyAE3wzwXz78Xz4kgCHaNISLSB7DumvxeWBak22JyGfKhPnZHJPrHx)    
           
       对于二维图像来说，常用二维零均值离散高斯函数作平滑滤波器。  
       二维高斯函数为：   
       ![enter image description here](https://lh3.googleusercontent.com/NoCjUDXZh6jdTyem3TKv38erW_RVfCXjVZxElVf1p7Wb6iCr9IzsxLy5focGfAy60BjJA1uG_Lck)    
       
     - 优点  
       首先，二维高斯函数是旋转对称的，在各个方向上平滑程度相同，不会改变原图像的边缘走向。
       其次，高斯函数是单值函数，高斯卷积核的锚点为极值，在所有方向上单调递减，锚点像素不会受到距离锚点较远的像素影响过大，保证了特征点和边缘的特性。
- 非线性滤波
	- 中值滤波   
	  简言之中值滤波就是把函数框（如图中的3 X 3）内的灰度值按顺序排列，然后中值取代函数框中心的灰度值。所以一般采用奇数点的邻域来计算中值，但如果像素点数为偶数，中值就取排序像素中间两点的平均值。   
	  - 优点  
	    中值滤波在一定的条件下可以克服常见线性滤波器如方框滤波器、均值滤波等带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。  
	  - 缺点   
	    因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上
	- 双边滤波   
	   双边滤波（Bilateral filter）是一种非线性的滤波方法，是**结合图像的空间邻近度和像素值相似度**的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。具有简单、非迭代、局部的特点。   
	   
	   双边滤波器的好处是可以做边缘保存（edge preserving），一般用高斯滤波去降噪，会较明显地模糊边缘，对于高频细节的保护效果并不明显。双边滤波器顾名思义比高斯滤波多了一个高斯方差sigma－d，它是基于空间分布的高斯滤波函数，所以在边缘附近，离的较远的像素不会太多影响到边缘上的像素值，这样就保证了边缘附近像素值的保存。但是由于保存了过多的高频信息，对于彩色图像里的高频噪声，双边滤波器不能够干净的滤掉，只能够对于低频信息进行较好的滤波。    
	   
	   距离越近权重越大，这一点和方框滤波，高斯滤波方式相同。而r函数则是根据像素的差异来分配权值。如果两个像素值越接近，即使相距较远，也比差异大而距离近的像素点权重大。正是r函数的作用，使得边缘，即相距近但差异大的像素点的特性得以保留。
	   参考：[https://www.jianshu.com/p/8d11e26c9665]   
### 图像数字化   
- 图像采样   
  图像在位置上的离散化叫做采样。
  采样图像的均匀量化。   

- 数字图像主要由采样点数和灰度级决定。采样点数和灰度级也决定图像的数据量和图像分辨率。     
  - N和k与图像分辨率的关系   
	  - 空间分辨率    
	     空间分辨率与采样点数N相关   
	 - 幅度分辨率  
	   幅度分辨率与灰度级k有关
### 图像增强   
- **图像对比度增强**   
  图像成像过程中，由于环境限制等因素影响，生成图像往往对比度不足，造成图像的视觉效果差。   
  对此，可采用图像灰度值变换的方法，改变灰度值从而改变图像灰度的动态范围，增强图像对比度。公式可表示为：   
  $$g(m,n)=T[f(m,n)]$$   
  - **灰度线性变换**   
	- **线性变换**
	    灰度线性变换是将图像灰度值按给定线性函数进行变换，增强或减弱图像的灰度，达到增强图像对比度的目的。   
	    设原图像灰度范围$f(m,n) \in [a,b]$，线性变换后为$g(m,n)\in [c,d]$。线性变换公式为：   
	    $$g(m,n)=c+k[f(m,n)-a]$$   
	    - 扩展动态范围   
	      当k>1，结果会使图像的动态范围展宽，可以改善曝光不足的缺陷。   
	    -  改变取值取间   
	     当k=1时，动态范围不变，取值取间会平移。
	    - 缩小动态范围   
	     0<k<1时，图像的动态范围会变窄。   
	    - 取反   
	     当k<0时，灰度值反转，亮的地方变暗，暗的地方变亮。  
    - **灰度分段线性变换**    
	    有些情况下，图像的整个灰度范围很宽，但感兴趣的灰度值的动态范围窄。可以分段线性变换   
	     - 扩展感兴趣的，牺牲其他   
	       对感兴趣的用大于1的k来扩展，其他区间用固定值表示。
	    - 扩展感兴趣的，压缩其他   
	       与以上不同的时，不感兴趣的其他区间压缩的方法。  
  - **非线性变换**    
     - **对数变换**   
     
       表达式：$g(m,n)=\lambda lg[1+f(m,n)]$   
       
       $\lambda$作为调节常数，调节变换后的灰度。对数变换的作用是扩展图像的低灰度范围，压缩图像的高灰度范围，使得图像的灰度分布均匀，与人的视觉特性相匹配。   
   - **指数变换**  
     与对数变换相反，指数变换是压缩图像的低灰度范围，扩展图像的高灰度范围：   
     $$g(m,n)=\lambda [f(m,n)+\epsilon]^\gamma$$  
     当$\gamma<1$，将原图像的灰度向高亮度映射，当图像整体偏暗时，可以应用此情况。当$\gamma>1$，将图像灰度向低亮度映射，当图像有“冲淡”外观时，可以应用此情况。   

- **图像直方图修正**    
  - 直方图均衡化是对原图进行灰度变换，使变换后图像的直方图均匀分布，使大区域中微笑灰度变化显现出来。直方图均衡化就是对图像进行非线性拉伸         
  - 必须要保证两个条件：①像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；②如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界   
  - 步骤：  
    - 统计各个灰度级的像素值个数  
    - 计算图像的直方图，即各个灰度级的出现概率。  
    - 计算累计分布函数，即累计直方图   
    - 利用映射函数，根据灰度值以及对应的累计分布函数对应值，进行公式计算，得到对应新的灰度值。   
       $$s_k = T(r_k)$$   
       公式可以有多种：  
         - 直接输出，将累计分布函数对应的值直接作为新灰度值
         - $h(v) = round(\frac{cdf(v)-cdf_{min}}{M*N-cdf_{min}})*(L-1)$  
           > 其中cdf(v)代表对应累计分布函数的值，cdf_min代表分布函数中最小值，M,N分别代表长度宽度。L代表灰度级个数（通常为8位动态范围，256个灰度级）   
        - $h(v)=INT((L-1)*cdf(v)+0.5)$

   - 结果：
     - 把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布
     - 其结果扩展了图像的动态范围
   - 优缺点   
     - 优点：这种方法对于背景和前景都太亮或者太暗的图像非常有用，这种方法尤其是可以带来X光图像中更好的骨骼结构显示以及曝光过度或者曝光不足照片中更好的细节。这种方法的一个主要优势是它是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大。    
     
     - 缺点：这种方法的一个缺点是它对处理的数据不加选择，它可能会增加背景杂讯的对比度并且降低有用信号的对比度；变换后图像的灰度级减少，某些细节消失；某些图像，如直方图有高峰，经处理后对比度不自然的过分增强。
  - 该方法可逆：
    如果已经均衡化函数，该问题可逆。
- **直方图规定化**  
  - 直方图均衡化能自动增强图像的整体对比度，但是往往结果难以受到控制。实际中常常需要增强某个特定灰度值范围内的对比度或使图像灰度值的分布满足特定需求。这个时候使用直方图规定化会有较好的结果。     
  - 步骤：
    - 对原直方图均衡化，求其累计直方图   
    - 对规定直方图均衡化，求其累计直方图  
    - 根据累积直方图，按照最靠近原则进行i-j变换。
### 噪声  
- 椒盐噪声（脉冲噪声）  
  椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。它是一种随机出现的白点或者黑点。是孤立存在的。
### 滤波   
- **线性滤波**
	- **均值滤波**   
	  输出像素是窗口内所有所有像素值的平均值    
	  领域范围N越大，噪声削弱程度越大，就越平滑。均值滤波不适用于椒盐噪声。容易使目标物体边缘或细节变模糊。
   - **高斯滤波**   
     高斯滤波器是一类根据高斯函数来选择权值的线性平滑滤波器。   
     
     - **高斯滤波的重要两步就是先找到高斯模板然后再进行卷积**。 
       - 生成模板   
         根据二维高斯分布函数生成滤波模板。   
        ![enter image description here](https://lh3.googleusercontent.com/74ay1KImMPiveZFHq8Ro0j1TG_VmLqDovzS9bgDDKdrsHglTbhBdYuewraOOG_o99qm8NiR28_5C)    
         例如假定标准差$\sigma=1.5$生成模板：  
          ![enter image description here](https://lh3.googleusercontent.com/jRD0VaF7UGIVHgTobKx1_mjqCpA-FUKXMNsn3LenGPGS-7VVrZzgOgu7rrYKSkfSJfgI_ntFdzEu)    
           这个时候我们我们还要确保这九个点加起来为1（这个是高斯模板的特性），这9个点的权重总和等于0.4787147，因此上面9个值还要分别除以0.4787147，得到最终的高斯模板   
          
       - 根据模板进行卷积
     - 特性  
       - 高斯滤波适用于高斯噪声  
       - 二维高斯函数具有旋转对称性，即滤波器在各个方向上的平滑程度是相同的。一般来说，一幅图像的边缘方向是事先不知道的，因此，在滤波前是无法确定一个方向上比另一方向上需要更多的平滑．旋转对称性意味着高斯平滑滤波器在后续边缘检测中不会偏向任一方向
       - 高斯函数是单值函数，每一邻域像素点权值是随该点与中心点的距离单调增减的。根据距离进行滤波。
       - 高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ，可在图像特征过分模糊(过平滑)与平滑图像中由于噪声和细纹理所引起的过多的不希望突变量(欠平滑)之间取得折衷
- **非线性滤波**

	- **中值滤波**     
	  同样是空间域的滤波，主题思想是取相邻像素的点，然后对相邻像素的点进行排序，取中点的灰度值作为该像素点的灰度值。  
	  - 特性 
	    - 对椒盐噪声，脉冲噪声有很好的抑制同时又能保留边缘细节。   
	      >原因：椒盐噪声是随机出现的白点或黑点，均值滤波的话这种0，1点会极大影响均值。而求中值则不会对原像素值影响很大。  
	         
	    - 中值滤波的缺点也很明显，因为要进行排序操作，所以处理的时间长，是均值滤波的5倍以上
	- **双边滤波**   
	  -双边滤波(Bilateral filter)也是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折衷处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的。   
	  - 公式：   
	  ![enter image description here](https://lh3.googleusercontent.com/_5SoGkOMu5NhCqeKZmsDU2gj_S8X96nQDdv6gOH6v9KB3uz_86yL1bTIboEjA63pmk2WdQW47OmF)    
	  加权系数w(i,j,k,l)取决于空域核和值域核的乘积    
	    - 其中空间核    
	      ![enter image description here](https://lh3.googleusercontent.com/ZMZjmjFNHjm8Q3bAHy0TjvsNlxHaASHMmwAPdM0Gtka2I9rO4v5iOHq3SJ6KvJrW_v5ROwdtZ7L8)
	    - 值域核    
	       ![enter image description here](https://lh3.googleusercontent.com/gZkGssIbB4jaDxknn9egJVLajY-aTlD-BIutXU4yASi6R-1i5KaUQxHbgFudTMJdLKlfj4n-Bw10)   

		  两者相乘得到双边滤波的权重核。  
      - 特点   
         - 均值模糊无法克服边缘像素信息丢失的缺陷，原因是均值滤波是基于平均权重的。
         - 高斯模糊部分克服了该缺陷，但无法完全避免，因为没有考虑像素值的不同  
         - 高斯双边模糊-是边缘保留额滤波方法，避免了边缘信息丢失，保留了图像轮廓不变   

### 边缘检测  
边缘其实就是图像上灰度级变化很快的点的    

根据检测梯度方向不同有不同检测算子   
- 正交梯度检测   
  在x,y方向上进行梯度计算，进行边缘检测  
- sobel 算子
<!--stackedit_data:
eyJoaXN0b3J5IjpbNDkxNTM4MjcsLTE1MDY0NzEwNDEsLTEzMD
MwODk5NzYsMTY2Mzk1MTI2NCwxMDQ5OTg0MzYwLDE2MTg0NTIz
ODAsLTQ5MDMzNzk5NCw2MTczNDExODMsLTE5NTk5MDgwMjAsMT
IyMTc4OTEyNCwtNTczNTI2MDkxLC0xNDMzNjIwOTkzLC0zNTEw
NzU5MDUsMzk3Mjc4NzE3LDkzMjU1NjM2NCwyODg0MjIwMSw4Nz
A3NDk5NDMsLTEzNjYzOTU4MzAsLTE3Mjc1Nzc3NTAsMzM2NzY5
MjQzXX0=
-->